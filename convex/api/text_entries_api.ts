/* eslint-disable @typescript-eslint/no-unused-vars */
import { z } from "zod";
import type { Knex } from "knex";
import type { AppSchema, TextEntry } from "../schema";
import type { HandlerContext } from "../../server/server"; // Import HandlerContext

// Define the expected structure of arguments for addTextEntry
const AddTextEntryArgsSchema = z.object({
  content: z.string().min(1),
});

// Query to get all text entries, ordered by creation date
export async function getTextEntries(
  { db }: HandlerContext,
  _args: Record<string, unknown> // No arguments for this query
): Promise<TextEntry[]> {
  console.log("Executing getTextEntries in text_entries_api.ts");
  const entries = await db("text_entries")
    .select("*")
    .orderBy("_createdAt", "asc");
  // Ensure _id is a string, and createdAt is a number (timestamp)
  return entries;
}

// Mutation to add a new text entry
export async function addTextEntry(
  { db, appSchema, broadcastQueryUpdate }: HandlerContext, // Add broadcastQueryUpdate
  args: unknown
): Promise<TextEntry> {
  const validationResult = AddTextEntryArgsSchema.safeParse(args);
  if (!validationResult.success) {
    throw new Error(
      `Invalid arguments for addTextEntry: ${validationResult.error.message}`
    );
  }
  const { content } = validationResult.data;

  const newTextEntryData = {
    // _id will be generated by Zod or DB if not provided and schema expects it
    content,
    // createdAt will be generated by Zod if schema defines it with default, or handled by DB
  };

  // Validate with Zod schema for text_entries
  // This will add default values like _id and createdAt if defined in the schema
  const validatedNewEntry = appSchema.text_entries.parse(newTextEntryData);

  // Knex returns an array of inserted ids, or an array of objects for some drivers.
  // We expect a single insert, so we'll take the first if it's an array of objects or assume the id is part of validatedNewEntry.
  await db("text_entries").insert(validatedNewEntry);

  // After insertion, fetch all text entries to broadcast the updated list
  const allTextEntries = await getTextEntries(
    { db, appSchema, broadcastQueryUpdate },
    {}
  ); // Pass context again
  broadcastQueryUpdate("getTextEntries", allTextEntries);

  // The `validatedNewEntry` should now have the _id and createdAt fields
  // populated by Zod's default or transform functions if they were defined.
  // If the DB auto-generates them and Zod doesn't, a re-fetch might be needed
  // for the exact returned entry, but for this broadcast, the whole list is fine.
  // For the return value of this mutation, `validatedNewEntry` is what was parsed and attempted to insert.
  // It's crucial that `appSchema.text_entries.parse` correctly assigns _id and createdAt.
  return validatedNewEntry as TextEntry; // Cast as TextEntry, assuming parse handles defaults
}

// Metadata to indicate which tables are affected by mutations in this file
export const affectedTablesByTextEntriesApi = {
  addTextEntry: ["text_entries"],
};
