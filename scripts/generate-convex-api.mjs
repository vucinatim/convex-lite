import fs from "fs/promises";
import path from "path";

// --- Configuration ---
const API_DIR = path.resolve("convex/api");
const ADMIN_API_DIR = path.resolve("convex/admin");
const GENERATED_DIR = path.resolve("convex/_generated");
const OUTPUT_FILE_JS = path.join(GENERATED_DIR, "api.js");
const OUTPUT_FILE_D_TS = path.join(GENERATED_DIR, "api.d.ts");

// --- Helper Functions ---

async function findApiExports(filePath) {
  const content = await fs.readFile(filePath, "utf-8");
  const functions = [];
  // UPDATED REGEX: Looks for `export const myFunction = ...`
  const localRegex = /export\s+const\s+([A-Za-z_][A-Za-z0-9_]*)/g;
  let match;
  while ((match = localRegex.exec(content)) !== null) {
    if (match[1]) functions.push(match[1]);
  }
  return functions;
}

function toCamelCase(str) {
  return str.replace(/([-_][a-z])/gi, (group) =>
    group.toUpperCase().replace("-", "").replace("_", "")
  );
}

// --- Main Generation Logic ---

async function generateApi() {
  const modules = {};

  const processDirectory = async (dir, dirIdentifier = "") => {
    try {
      const files = await fs.readdir(dir);
      for (const file of files) {
        if (file.endsWith("_api.ts")) {
          const filePath = path.join(dir, file);
          // Use the updated function name
          const functions = await findApiExports(filePath);

          if (functions.length > 0) {
            const moduleNameInApiObject = toCamelCase(
              dirIdentifier
                ? `${dirIdentifier}_${file.replace("_api.ts", "")}`
                : file.replace("_api.ts", "")
            );

            const relativePath = path
              .relative(GENERATED_DIR, filePath)
              .replace(/\\/g, "/")
              .replace(/\.ts$/, "");
            const moduleAlias = toCamelCase(file.replace(".ts", ""));

            modules[moduleNameInApiObject] = {
              functions,
              identifierPrefix: dirIdentifier ? `${dirIdentifier}_` : "",
              originalModuleName: file.replace("_api.ts", ""),
              moduleAlias,
              importPath: relativePath,
            };
          }
        }
      }
    } catch (error) {
      if (error.code !== "ENOENT")
        console.error(`Error processing directory ${dir}:`, error);
    }
  };

  await processDirectory(API_DIR, "");
  await processDirectory(ADMIN_API_DIR, "admin");

  const fileHeader = `// This file is auto-generated by scripts/generate-convex-api.mjs
// Do not edit this file directly.
/* eslint-disable */
/* tslint:disable */
`;

  const sortedModuleNames = Object.keys(modules).sort();

  let jsContent = `${fileHeader}\nexport const api = {\n`;
  for (const moduleName of sortedModuleNames) {
    jsContent += `  ${moduleName}: {\n`;
    const { functions, identifierPrefix, originalModuleName } =
      modules[moduleName];
    functions.sort().forEach((fnName) => {
      jsContent += `    ${fnName}: "${identifierPrefix}${originalModuleName}:${fnName}",\n`;
    });
    jsContent += "  },\n";
  }
  jsContent += "};\n";

  let dtsContent = `${fileHeader}\n`;
  for (const moduleName of sortedModuleNames) {
    const { moduleAlias, importPath } = modules[moduleName];
    dtsContent += `import type * as ${moduleAlias} from "${importPath}";\n`;
  }
  dtsContent += `\n/**\n * A type helper to build the API from modules, preserving the original function definitions.\n */\ntype ApiFromModules<Modules extends Record<string, any>> = {\n  [ModuleName in keyof Modules]: Modules[ModuleName];\n};\n\n`;
  dtsContent += `declare const fullApi: ApiFromModules<{\n`;
  for (const moduleName of sortedModuleNames) {
    dtsContent += `  ${moduleName}: typeof ${modules[moduleName].moduleAlias};\n`;
  }
  dtsContent += `}>;\n\n`;
  dtsContent += `export declare const api: typeof fullApi;\n`;

  await fs.mkdir(GENERATED_DIR, { recursive: true });
  await fs.writeFile(OUTPUT_FILE_JS, jsContent);
  await fs.writeFile(OUTPUT_FILE_D_TS, dtsContent);

  console.log(`âœ… Generated API runtime at ${OUTPUT_FILE_JS}`);
  console.log(`âœ… Generated API types at ${OUTPUT_FILE_D_TS}`);
  console.log("ðŸš€ API generation complete.");
}

generateApi().catch(console.error);
