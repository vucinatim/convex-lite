import fs from "fs/promises";
import path from "path";
import { getApiFiles } from "../server/utils/file-discovery";

// --- Configuration ---
const CONVEX_DIR = path.resolve("convex");
const GENERATED_DIR = path.join(CONVEX_DIR, "_generated");
const OUTPUT_FILE_JS = path.join(GENERATED_DIR, "api.js");
const OUTPUT_FILE_D_TS = path.join(GENERATED_DIR, "api.d.ts");

/**
 * A robust regex to find named `const` exports, which is how our
 * query() and mutation() functions are defined.
 */
async function findApiExports(filePath) {
  const content = await fs.readFile(filePath, "utf-8");
  const functions = [];
  const localRegex = /export\s+const\s+([A-Za-z_][A-Za-z0-9_]*)/g;
  let match;
  while ((match = localRegex.exec(content)) !== null) {
    if (match[1]) functions.push(match[1] as never);
  }
  return functions;
}

function toCamelCase(str) {
  return str.replace(/([-_][a-z])/gi, (group) =>
    group.toUpperCase().replace("-", "").replace("_", "")
  );
}

// --- Main Generation Logic ---

async function generateApi() {
  const modules = {};

  // Use the recursive generator to find all API files.
  for await (const filePath of getApiFiles(CONVEX_DIR)) {
    const functions = await findApiExports(filePath);

    if (functions.length > 0) {
      // Create a unique module key from the file path relative to `convex/`.
      // e.g., 'tasks/queries.ts' -> 'tasks_queries'
      const moduleKey = path
        .relative(CONVEX_DIR, filePath)
        .replace(/\.(ts|js)$/, "") // Remove extension
        .replace(/[/\\]/g, "_"); // Replace path separators with underscores

      const camelCasedModuleKey = toCamelCase(moduleKey);

      // Create a unique alias for the import statement.
      // e.g., 'tasks/queries.ts' -> 'tasksQueries'
      const moduleAlias = toCamelCase(moduleKey);

      // Create the relative path for the import statement.
      const importPath = path
        .relative(GENERATED_DIR, filePath)
        .replace(/\\/g, "/")
        .replace(/\.(ts|js)$/, "");

      modules[camelCasedModuleKey] = {
        functions,
        identifierPrefix: `${moduleKey}:`,
        moduleAlias,
        importPath,
      };
    }
  }

  const fileHeader = `// This file is auto-generated by scripts/generate-convex-api.mjs
// Do not edit this file directly.
/* tslint:disable */
`;

  const sortedModuleNames = Object.keys(modules).sort();

  // --- Generate api.js content (for runtime) ---
  let jsContent = `${fileHeader}\nexport const api = {\n`;
  for (const moduleName of sortedModuleNames) {
    jsContent += `  ${moduleName}: {\n`;
    const { functions, identifierPrefix } = modules[moduleName];
    functions.sort().forEach((fnName) => {
      jsContent += `    ${fnName}: "${identifierPrefix}${fnName}",\n`;
    });
    jsContent += "  },\n";
  }
  jsContent += "};\n";

  // --- Generate api.d.ts content (for types and "Go to Definition") ---
  let dtsContent = `${fileHeader}\n`;
  for (const moduleName of sortedModuleNames) {
    const { moduleAlias, importPath } = modules[moduleName];
    dtsContent += `import type * as ${moduleAlias} from "${importPath}";\n`;
  }
  dtsContent += `\n/**\n * A type helper to build the API from modules, preserving the original function definitions.\n */\ntype ApiFromModules<Modules extends Record<string, unknown>> = {\n  [ModuleName in keyof Modules]: Modules[ModuleName];\n};\n\n`;
  dtsContent += `declare const fullApi: ApiFromModules<{\n`;
  for (const moduleName of sortedModuleNames) {
    dtsContent += `  ${moduleName}: typeof ${modules[moduleName].moduleAlias};\n`;
  }
  dtsContent += `}>;\n\n`;
  dtsContent += `export declare const api: typeof fullApi;\n`;

  await fs.mkdir(GENERATED_DIR, { recursive: true });
  await fs.writeFile(OUTPUT_FILE_JS, jsContent);
  await fs.writeFile(OUTPUT_FILE_D_TS, dtsContent);

  console.log(`âœ… Generated API runtime at ${OUTPUT_FILE_JS}`);
  console.log(`âœ… Generated API types at ${OUTPUT_FILE_D_TS}`);
  console.log("ðŸš€ API generation complete.");
}

generateApi().catch(console.error);
